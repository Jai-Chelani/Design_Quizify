ATM-

1)Singleton Pattern – to ensure only one instance of the ATM controller exists.
2)Strategy Pattern – to apply different fee calculation strategies based on the account type
3)Factory Pattern – to create different types of transactions.
4)Observer Pattern – to notify account holders about transaction status.



*Singleton Pattern
 UC-Ensures that the ATM system has only one instance, such as the ATM controller or ATM session manager.
 R-An ATM typically has one central point of control (for managing the state, initiating sessions, etc.), so this pattern is useful to avoid creating multiple instances.
 Eg-The ATM controller class that coordinates the operations of the ATM could be a singleton to ensure only one instance manages the ATM's lifecycle

*Strategy Pattern
 Allows different algorithms to be used interchangeably, for example, for fee calculation, transaction processing (eg Withdraw, Deposit), or validation strategies.
 ATM systems can support different transaction types (withdrawal, deposit, balance inquiry), and different strategies for account fee calculation (eg different rules for standard accounts versus premium accounts).
 The fee calculation might be implemented as a strategy so the ATM can switch between different fee policies for different types of accounts (eg premium vs. regular).

*Factory Pattern
 Provides a way to create different types of objects (transactions, account types) without specifying the exact class of object that will be created.
 You can use this pattern to create specific transaction objects (Withdraw, Deposit, BalanceInquiry) based on user input without hard-coding the exact class.
 A TransactionFactory can be used to create different transaction objects depending on the user’s choice (eg withdrawing money, depositing money, etc.).

*Observer Pattern
 Notifies multiple objects (observers) when the state of the ATM changes (eg transaction completed, balance updated).
 The ATM system might need to notify other parts of the system, such as an account holder’s app or a backend service, whenever a transaction is completed or certain conditions are met.
 The ATM can notify account holders or other observers when a transaction is completed (like notifying a mobile app when a withdrawal occurs).

Singleton Pattern, and Factory Pattern would be the most important patterns to focus on for designing the core of the ATM system. Here’s why:

**Singleton Pattern guarantees that the ATM controller has only one instance, ensuring global control over the system’s state and operations.

**Factory Pattern provides flexibility in creating different types of transactions dynamically, without complicating the system.

Multithreading:-
Multithreading in an ATM system plays a crucial role in enabling concurrent operations and improving the system's performance, scalability, and responsiveness. By using multiple threads, an ATM system can handle multiple users or multiple tasks simultaneously without blocking or slowing down the system. This is especially important in an environment where many users might be interacting with the ATM at the same time.

Here’s how multithreading can be useful in an ATM system:

i) Simultaneous User Interactions
ii)Concurrency in Transactions
iii)Non-blocking User Interface (UI)
iv)Handling I/O Operations
v) Network Communication
vi)Security and Transaction Validation
vii)Task Scheduling
viii)Performance and Scalability